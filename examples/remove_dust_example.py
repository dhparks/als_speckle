import speckle,numpy,time
speckle.io.set_overwrite(True)

# This file demonstrates the use of the remove_dust function in the conditioning
# module. First we simulate some basic scattering data which is afflicted by
# dust, then call the remove_dust routine.

# *** This file creates a map of the dust based on the known locations of the
# dust, but in analyzing experiments a map of the dust must be supplied ***

### Data simulation section ###

# make a partially coherent airy pattern
N   = 1024
R   = 40

print "making airy pattern"
obj = speckle.shape.circle((N,N),R)*(1+.05*numpy.random.randn(N,N))
cf  = numpy.fft.fftshift(speckle.shape.gaussian((N,N),(100,100))) # coherence
airy_fc = numpy.fft.fftshift(abs(numpy.fft.fft2(obj))**2)
airy_pc = numpy.fft.ifft2(cf*numpy.fft.fft2(airy_fc))

# generate the dust
density  = .001
sizes    = (1,3,5) # size of the dust specks. easiest if odd integers.
all_dust = numpy.zeros_like(airy_pc)

print "adding dust"
for size in sizes:
    
    print "  size %s"%size
    # place the dust locations in a 2d array
    n      = density*N*N/len(sizes)
    coords = (N*numpy.random.rand(2,n)).astype(numpy.int32)
    dust   = numpy.zeros((N,N),numpy.float32)
    dust[coords.tolist()] = 1.
    fd = numpy.fft.fft2(dust)
    
    # replace the delta functions via convolution
    if size > 1:
        k = numpy.zeros_like(dust)
        l = round(size/2.)
        r = size-l
        k[:l,:l]   = 1
        k[:l,-r:]  = 1
        k[-r:,:l]  = 1
        k[-r:,-r:] = 1
        
        # convolve and add to all_dust
        convolved = abs(numpy.fft.ifft2(fd*numpy.fft.fft2(k)))
        all_dust += numpy.clip(convolved,-.01,1.01)

# now that the dust has been generated, simulate its effect by simply
# multiplying against the diffraction pattern
all_dust  = numpy.clip(all_dust,0,1)
airy_dust = (1-all_dust)*airy_pc

### Dust removal section ###

# To remove the dust, we just have to pass the dust map (here, known already)
# and the dusty image to conditioning.remove_dust(). In experimental data,
# the dust map must be generated by some other method. Notice that two
# arguments are returned. dust_plan can be reused to save time, as generation
# of the plan is time-consuming.

dust_map = speckle.shape.circle((N,N),250,AA=0)*all_dust # I'm just going to remove the dust near the center
t0 = time.time()
dust_removed, dust_plan  = speckle.conditioning.remove_dust(airy_dust,dust_map)
t1 = time.time()
dust_removed2, dust_plan = speckle.conditioning.remove_dust(airy_dust,dust_map,dust_plan=dust_plan)
t2 = time.time()

print "Dust removal times:"
print "  First pass %s seconds"%(t1-t0)
print "  Second pass %s seconds"%(t2-t1)
print "Time difference is from reusing the dust_plan"

### Output section ###
speckle.io.save('airy with dust.png',airy_dust**0.25)
speckle.io.save('airy dedusted.png',dust_removed**0.25)
speckle.io.save('airy dust map.png',dust_map*255)
speckle.io.save('airy dust plan.png',dust_plan*255)


    
    
    
    